<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Portfolio -  Troyer</title>
    <script src="script.js"></script>
    <link rel="stylesheet" href="style.css"/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
          rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-4Q6Gf2aSP4eDXB8Miphtr37CMZZQ5oXLH2yaXMJ2w8e2ZtHTl7GptT4jmndRuHDT" crossorigin="anonymous">
</head>
<body>
<div id="navbar-placeholder"></div>

<main>
    <nav class="traces-nav">
        <div class="traces-nav-content">
            <ul class="traces-nav-list">
                <li>
                    <a href="#trace-1" class="traces-nav-link">
                        <i class="fas fa-home"></i>
                        <span>Compétence n°1</span>
                    </a>
                </li>
                <li>
                    <a href="#trace-2" class="traces-nav-link">
                        <i class="fas fa-home"></i>
                        <span>Compétence n°2</span>
                    </a>
                </li>
                <li>
                    <a href="#trace-3" class="traces-nav-link">
                        <i class="fas fa-home"></i>
                        <span>Compétence n°3</span>
                    </a>
                </li>
            </ul>
        </div>
    </nav>
    <!-- Hero Section -->
    <section class="section min-hero-section">
        <div class="min-hero-background">
            <div class="min-gradient-overlay"></div>
        </div>
        <div class="container">
            <div class="min-hero-content">
                <div class="text-wrapper">
                    <h1 class="min-hero-title">
                        <span class="description">Traces</span>
                    </h1>
                    <div class="min-hero-text">
                        <p class="description">Analyse de différentes figure représentant les compétences et
                            l'expérience acquise au cours de cette premoière année de BUT informatique.</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Main Content Section -->
    <section class="section">
        <div class="container position-relative">

            <div class="trace-container">
                <!-- Trace 1 -->
                <div class="trace-item" id="trace-1">
                    <div class="trace-image">
                        <img src="images/trace-1_zng-wrfr.png" alt="Trace 1">
                        <p class="img-caption">Figure 1 : Zoning et wireframe de la page d'acceuil du site web de
                            rapport économique de la société Asobo</p>
                    </div>
                    <div class="trace-content">
                        <h2 class="pre-trace-title">Compétence visée n°1</h2>
                        <h2 class="trace-title">Conduction d'un projet - Maquettage d'une page d’accueil</h2>

                        <div class="trace-text">
                            <p>
                                La <i>Figure 1</i> est une double maquette basse fidélité (zoning + wireframe) de la
                                page
                                d’accueil d’un site web de présentation, conçu dans le cadre d’un projet de groupe. Ce
                                site a pour objectif de diffuser un rapport économique à destination d’un client
                                professionnel (une entreprise). La maquette présentée ici est purement visuelle et
                                statique : elle a été réalisée afin de valider l’architecture générale du site avec le
                                client, en amont du développement.
                                <br><br>
                                Cette maquette combine deux représentations complémentaires : à gauche, un zoning qui
                                permet de distinguer les grandes zones fonctionnelles de la page (logo, menu, carrousel,
                                blocs texte/image, pied de page…), et à droite, un wireframe qui détaille les contenus
                                types (titres, textes, boutons, emplacements d’images, gabarits de cartes, etc.). Ce
                                travail m’a permis de mettre en œuvre plusieurs savoirs fondamentaux liés à la
                                conception d’interfaces web, en particulier la structuration hiérarchique de
                                l’information (UX/UI), la définition de gabarits réutilisables et l’organisation
                                modulaire des pages.
                                <br><br>
                                Plus précisément, ce zoning respecte les principes de conception visuelle standard : une
                                zone d’en-tête fixée avec logo et navigation claire, une section de mise en valeur
                                (carrousel ou bannière), suivie de blocs alternés texte/image pour éviter la monotonie
                                visuelle, et enfin un pied de page. La répétition des gabarits textuels ou visuels dans
                                le wireframe (comme les sections de type "placeholder + texte + bouton") permet une
                                uniformisation graphique tout en facilitant l’intégration technique future
                                (HTML/CSS/JS).
                                <br><br>
                                Sa réalisation m’a conduit à mobiliser des principes essentiels de l’architecture web et
                                de la communication visuelle. Pour concevoir une page lisible, j’ai dû comprendre
                                comment guider le regard de l’utilisateur dès l’arrivée sur le site : cela passe par un
                                positionnement réfléchi des éléments-clés comme le menu, les appels à l’action, ou
                                encore le carrousel central qui capte l’attention. J’ai également dû veiller à maintenir
                                une cohérence visuelle entre les blocs, tout en jouant sur la variation (alternance
                                texte/image, équilibre des marges) afin d’éviter la monotonie. Le wireframe m’a permis
                                de détailler chaque section de contenu de manière suffisamment précise pour que le reste
                                de l’équipe puisse s’appuyer dessus lors du développement. Cela impliquait de réfléchir
                                aux futurs composants HTML/CSS, de prévoir une structure facilement découpable en
                                modules, et de tenir compte de contraintes de responsivité. Ce travail a aussi servi de
                                support de dialogue avec le client : il a facilité la validation des choix graphiques et
                                fonctionnels en rendant visibles les intentions sans avoir à coder.
                                <br><br>
                                Au fil des échanges et des retours obtenus lors des revues internes et externes,
                                plusieurs ajustements ont été nécessaires, aussi bien sur la hiérarchie de l’information
                                que sur le placement de certains blocs. Cela a conduit à la création de plusieurs
                                versions successives de la maquette, chacune intégrant des modifications ciblées, que ce
                                soit pour répondre à de nouvelles attentes du client ou améliorer la lisibilité et
                                l’utilisabilité de la page. Cette phase d’itération a été déterminante pour aboutir à
                                une proposition finale claire, équilibrée et techniquement exploitable.
                            </p>

                            <p>
                                Sur le plan technique, le zoning et le wireframe permettent d’anticiper la structure
                                HTML/CSS future et de limiter les aller-retours de correction entre le client et
                                l'équipe. Ils servent également de base à la définition des fonctionnalités dynamiques à
                                implémenter dans un second temps (carrousel interactif, affichage conditionnel des
                                données).
                                <br>
                                Ce travail illustre ainsi ma capacité à conduire un projet numérique structuré, en
                                intégrant à la fois les exigences du client, les besoins utilisateurs, et les
                                contraintes techniques. Il démontre également une bonne gestion du cycle de vie du
                                projet, depuis l’expression du besoin jusqu’à la production d’un livrable validé par les
                                différentes parties prenantes.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Trace 2 -->
                <div class="trace-item" id="trace-2">
                    <div class="trace-image">
                        <img src="images/trace-2_tests.png" alt="Trace 2">
                        <p class="img-caption">Figure 2 : réalisation de tests unitaires pour une application de type
                            jeu de plateau avec JUnit </p>
                    </div>
                    <div class="trace-content">
                        <h2 class="pre-trace-title">Compétence visée n°2</h2>
                        <h2 class="trace-title">Conduction d'un projet - Maquettage d'une page d’accueil</h2>
                        <div class="trace-text">
                            <p>
                                La Figure 2 est une capture d’écran issue du projet Orbito, un jeu de plateau développé
                                en une application Java, ce projet est ouvert dans l'interface de programmation IDEA.
                                <br>
                                Le projet repose sur l’utilisation du paradigme MVC (Modèle – Vue – Contrôleur), cela
                                implique donc une séparation stricte entre les éléments qui décrivent l’état du jeu,
                                ceux qui le représentent visuellement, et ceux qui gèrent les interactions. Cette
                                application à également implémenter la bibliothèque « boardifier », permettant de
                                faciliter l’affichage d’un jeu de plateau en fournissant des classes à redéfinir et à
                                hériter.
                                <br> <br>
                                L’intérêt de ce genre de classe est de tester le bon fonctionnement des méthodes
                                intégrées à l’application. Le bon fonctionnement est lorsque la méthode renvoie bien ce
                                que nous attendons d’elle. Un test est comporte donc des appels des méthodes testées,
                                vérifiant que le résultat renvoyé par l’appel est bien le résultat attendu pour les
                                paramètres fournis par ce test. Dans le jargon du test unitaire, cela s’appelle vérifier
                                un oracle. En pratique, les test unitaires permettent de vérifier « facilement » si des
                                modifications dans une méthode la font « régresser », donc, qu’elle ne fonctionne plus
                                correctement. Le test unitaire est donc une brique fondamentale dans la maintenance et
                                l’évolutivité logicielle.
                                <br> <br>
                                La Firgure 2 illustre les tests unitaires appliqués à la partie "Contrôleur". La partie
                                responsable de la gestion des règles du jeu et des décisions à appliquer. La réalisation
                                de ces tests se fait avec les bibliothèques JUnit et Mockito, permettant de l’écriture
                                de test unitaire basique.
                                Le code visible appartient à la classe OrbitoControllerUnitTest, située dans le
                                répertoire test/controller, en cohérence avec l’organisation typique des projets MVC
                                structurés en packages. La classe ne comporte que 5 classes, celle ci couvrent une
                                partie des méthodes définies dans le controller, bien qu’il n’y ait que ces quelques
                                tests, ceux ci permettent de couvrir une grande partie des méthodes de la classe testée.
                                <br> <br>
                                Le test principal affiché, testCheckMarblePlayer, est relativement simple dans son
                                fonctionnement, mais il applique des notions essentielles de la vérification logicielle.
                                Il vise à tester une méthode du contrôleur chargée de vérifier si une bille (marble)
                                appartient bien au joueur courant, celui dont c’est le tour. Pour cela, le test simule
                                un environnement contrôlé grâce à la bibliothèque Mockito, une bille fictive est créée,
                                ce qui permet de réaliser une instance fictive de son comportement sans avoir à
                                construire un réel objet complet du jeu.
                                <br>
                                Il a donc fallu que j’utilise when(nom_méthode).thenReturn(résultat_voulu), qui sert à
                                simuler dynamiquement la couleur retournée par la bille en fonction du contexte du test.
                                Le contrôleur est configuré pour simuler tour à tour un joueur blanc, puis noir, et
                                l’objectif est de vérifier que la méthode réagit correctement selon ces conditions.
                                Le test utilise les assertions de JUnit assertTrue et assertFalse, vérifiant que la
                                méthode, qui renvoie un booléen, vérifie de la correcte manière la couleur de la bille
                                et de sa relation avec le joueur courant. Cela permet l’évaluation du comportement de la
                                méthode : si la réponse obtenue ne correspond pas à ce qui est attendu, le test échoue
                                automatiquement. Les 4 assertions présentes dans ce test sont suffisantes pour tester
                                toutes les possibilités de la méthode testée.
                                <br>
                                Ce test à donc pour but de garantir que les règles sont correctement appliquées,
                                indépendamment de l’interface ou du modèle.
                                <br> <br> <br>
                                Cette capture d’écran ayant été réalisée durant la réalisation de ce projet, toutes les
                                classes de tests finales ne sont pas visibles. Ces classes de tests permettent tout de
                                même d’obtenir une couverture de 69% pour les fichiers testés, selon le calcul l’outil
                                d’audit d’Idea, ce qui correspond aux classes couvertes par ces tests, et du fait que
                                les classes du la partie "view" du MVC servant à l’affichage n’étaient pas testables
                                avec des tests unitaires.
                                Le succès des cinq tests affichés en bas de l’écran montre que les différents cas prévus
                                se comportent comme attendu. Cela ne garantit pas l’absence totale d’erreurs, mais c’est
                                un indicateur précieux de stabilité. Je considère néanmoins que ces tests restent
                                simples, et que pour progresser davantage, je devrai apprendre à concevoir des scénarios
                                de test plus complexes, prenant en compte davantage de paramètres, d’interactions et de
                                cas limites.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Trace 3 -->
                <!--                <div class="trace-item" id="trace-3">-->
                <!--                    <div class="trace-image">-->
                <!--                        <img src="images/projet.png" alt="Trace 2">-->
                <!--                        <p class="img-caption">Figure 3 : </p>-->
                <!--                    </div>-->
                <!--                    <div class="trace-content">-->
                <!--                        <h2 class="pre-trace-title">Compétence visée n°3</h2>-->
                <!--                        <h2 class="trace-title">Compétence - Application de celle ci</h2>-->
                <!--                        <div class="trace-text">-->
                <!--                            <p>Content for the second trace. The image will stick to the side while scrolling through-->
                <!--                                this content.-->
                <!--                                . </p>-->
                <!--                            <p>Add more paragraphs as needed for your trace content.</p>-->
                <!--                        </div>-->
                <!--                    </div>-->
                <!--                </div>-->

                <!-- Add more trace-item divs as needed -->
            </div>
        </div>
    </section>

    <div id="footer-placeholder"></div>

    <script src="script.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
</main>
</body>
</html>